[{"title":"Hello World","url":"/2023/06/30/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"实习","url":"/2023/06/30/%E6%A0%87%E9%A2%98/","content":"一、马踏棋盘问题描述将马随机放在国际象棋的8×8棋盘[0～7][0～7]的某个方格中，马按走棋规则进行移动。要求每个方格只进入一次，走遍棋盘上全部64个方格。编制递归和非递归程序，求出马的行走路线，并按求出的行走路线，将数字1，2，…，64依次填入一个8×8的方阵，输出之。\n程序代码棋盘定义\n#define ROW 8#define COL 8#define MAX_STEPS ROW*COL\n\n定义每次的改变的相对坐标\nint move_x[8] = &#123; 1, 2, 2, 1, -1, -2, -2, -1 &#125;;int move_y[8] = &#123; 2, 1, -1, -2, -2, -1, 1, 2 &#125;;\n\n方法1：DFS（递归）\n\nDfs 函数是深度优先遍历函数，使用递归方式实现。\n接受二维数组 path 表示棋盘，m 和 n 表示当前位置的坐标，edge 表示棋盘边长，count 表示已经访问的格子数。\n函数首先判断是否已经访问了所有的格子，如果是则直接返回。\n然后判断当前位置是否在棋盘范围内且未被访问过，如果是则增加已访问的格子数，将该位置标记为已访问，并进行递归调用，以便继续向下一位置探索。\n\n//深度优先遍历（递归）void Dfs(int path[8][8], int m, int n, int edge, int count)&#123;\tif (count &gt;= edge * edge)//如果走过的格子数大于等于棋盘数\t\treturn;\tif (m &lt;= edge - 1 &amp;&amp; n &lt;= edge - 1 &amp;&amp; m &gt;= 0 &amp;&amp; n &gt;= 0 &amp;&amp; path[m][n] == 0)//位置（m,n）在棋盘上，并且没有被走过\t&#123;\t\tcount++;//走过的格子数+1\t\tpath[m][n] = count;//把该位置的值改为第几个走过的格子\t\tfor (int i = 0; i &lt; edge; i++)\t\t\tDfs(path, m + move_x[i], n + move_y[i], edge, count);//进行递归，直到走过的格子数大于等于棋盘数\t\treturn;\t&#125;&#125;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n"}]